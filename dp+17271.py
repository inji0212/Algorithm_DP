#17271
# 리그 오브 레전설
# n초 동안 싸움 a,b스킬 사용
# a 1초 b m초 
# 스킬 조합, 시전시간동안 다른 스킬 사용할 수 없
# 스킬 안쓰고 있는 시간 없
# m-3 
#1-1,2-1,3-2,4-3 5-4 6-6 7-9 8-12 9-16
# 1 1
# 11 1
# 111,3 1+1
# 1111,13,31 1+2
# 11111,113,131,311 1+3
# 111111,1113,1131,1311,3111,33 1+4+1
# 1111111,11113,11131,11311,13111,31111,331,313,113 1+5+3
#11111111,111113,1133=1+6+6
#1 9개,1111113,11133,333=1+17+10+1
# 6:1+3 ,1+1 7: 1+4+1 1+2 8:1+5+3,1+3 9:1+6+6,1+4+1

#m의 배수가 되면 1부터 시작하는 새 리스트 시작
# m*i일 떄 i가 공차가 되는 리스트 시작
# 2차원이 되어서 시간도 오래걸리고빡셈 다른방법...
# dp는 전값에 어떤 값을 더하는 형태가 많던데..
# [i]=[i-1]+[i-
n,m=map(int,input().split())
a=[1]*(n+1)

for i in range(1,n+1):

  if i<m:
    a[i]=1
  else:
    a[i]=(a[i-1]+a[i-m])%1000000007
print(a[n])






#4초 m=2 
# aaaa,aab,baa,aba,bb
#1-1,2-2,3-3 4-5 5-8 6-12 7-18
# 1 1
# 11,2 1+1
# 111,12,21 1+2
# 1111,112,121,211,22 1+ 3+1
# 11111,1112,1121,1211,2111,122,212,221 1+4+3
# 1 6개,11112,1122,222 1+5+6+1 
# 1 7개,111112,11122,1222 1+6+8+4

#1, 1+1,1+2,1+3+1,1+4+3,1+5+5+1,1+6+7+4
# 4:1+2,1+1/5:1+3+1,1+2/6:1+4+3,1+2+1/
# 7:1+5+5+1,1+2+3

# i 를 구현하려면 1과 m을 눌렀을 때가능한 경우를 더하는것
# dp적으로 생각한다는 것은
# 앞경우들은 그 경우들의 최대 경우 
# 이 최대의 경우들에 무언가를 해서 현재의 최대경우를 
# 찾는 다는 생각?

# 데이터 나열해서 알아챘는지
# dp 특성생각해서 알아냈는지
# 이분 탐색할때 mid를 기준을 푼것처럼
# 현재는 알고리즘을 알고 풀기에 dp로 어떻게 사용하는지 
# 알아낼 수있엇다
# 이경우 구하는 것 정의하고
# 규칙을 파악한다.
# dp규칙이라하면 시간제한이 적다? 그럼 dp가 시간을 줄이는 거니까 
# 한번 한건 다시 안해서 줄일 수있는 알고리즘이니
# bfs 를 dp 형식을 이용해서 최단거리를 찾는데 이미 가봤으면 저장해서 다시 사용하면 시간이 줄어드니까 시간줄일때 유용

# 탑다운은 다 찾아보고 중복된걸 삭제해서 찾아보는 형태라 점화식은 안쓴다.